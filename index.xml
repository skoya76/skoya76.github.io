<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Koya's Blog</title><link>https://skoya76.github.io/</link><description>Recent content on Koya's Blog</description><generator>Hugo -- gohugo.io</generator><language>jp</language><lastBuildDate>Sat, 03 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://skoya76.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Various Consistencies</title><link>https://skoya76.github.io/posts/distsys/consistencies/</link><pubDate>Sat, 03 Sep 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/consistencies/</guid><description>本記事はdev.toから移植しました．
Introduction The word &amp;ldquo;consistency&amp;rdquo; has many meanings in computer science. In this article, we will explain the various consistency aspects of distributed system replication in a clear and straightforward manner.
Serializability State machine replication with linearizability sorts transactions into a sequence, and that sequence is guaranteed for all replicas. This is completely independent of real-world time.
Linearizability causes the problems shown in the following figure.
Linearizability only guarantees the update order between replicas, as shown in the figure above, and there is no way to know when that information will be transmitted to other replicas.</description></item><item><title>Failure Models</title><link>https://skoya76.github.io/posts/distsys/failuremodels/</link><pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/failuremodels/</guid><description>本記事はdev.toから移植しました．
Introduction The previous article explained the communication model for the timing of consensus problem. In this article, we will introduce four general definitions of failure models for consensus problem nodes.
Crash-stop faults This model only places the assumption that the node will Crash-stop faults. Also, a node that is stopped in this model never comes back.
Omission faults This model assumes Crash-stop faults and Omission faults. Omission faults may or may not reply to messages.</description></item><item><title>Communication Models</title><link>https://skoya76.github.io/posts/distsys/communicationmodels/</link><pubDate>Sun, 21 Aug 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/communicationmodels/</guid><description>本記事はdev.toから移植しました．
Introduction In a standard distributed computing environment, the presence of message-delaying attackers (Communication delays or failures) introduces communication uncertainty. Three communication models are broadly defined for the distributed systems consensus problem.
Synchronous Communication model The synchronous model defines a known finite time range ⊿ for message delivery, and an attacker can only cause a delay of at most ⊿ in the delivery of a message. In other words, when a sender sends a message, it is guaranteed to be received by the other party within a certain time ⊿.</description></item><item><title>Lamport Timestamp</title><link>https://skoya76.github.io/posts/distsys/timestamp/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/timestamp/</guid><description>本記事はdev.toから移植しました．
Introduction Lamport timestamp is a method proposed by Leslie Lamport for generating sequence numbers that are consistent with a causality law.
Lamport timestamp Each node (replica) is assigned a unique ID. (counter, NodeID) is the timestamp If the counters have the same value, the one with the larger node ID is considered the larger timestamp. (3,2) &amp;lt; (3,5) When a node generates a timestamp, it compares the largest value it is aware of with the client&amp;rsquo;s value and sets the larger value as the timestamp counter value.</description></item><item><title>Total Order Broadcast</title><link>https://skoya76.github.io/posts/distsys/tob/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/tob/</guid><description>本記事はdev.toから移植しました．
What is Total order? The way to determine if a given element is in total order is simple. That is, &amp;ldquo;Can you put those elements in a row?&amp;rdquo;.
For example, what if the natural numbers 7, 8, 1, 4, and 5 are given? We can then serialize 1&amp;lt;4&amp;lt;5&amp;lt;7&amp;lt;8. In other words, the natural numbers are total order.
What about the sets {b, d}, {d,d} {z, b} next? They cannot be serialized.</description></item><item><title>State Machine Replication</title><link>https://skoya76.github.io/posts/distsys/smr/</link><pubDate>Fri, 19 Aug 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/smr/</guid><description>本記事はdev.toから移植しました．
Introduction In computer science, state machine replication (SMR) or state machine approach is a general method for implementing a fault-tolerant service by replicating servers and coordinating client interactions with server replicas. The approach also provides a framework for understanding and designing replication management protocols [Wikipedia].
What is Fault-tolerant? Fault tolerance is simply the property that guarantees the provision of service without problems even if some of the replicated copies break down.</description></item><item><title>What is the MultiPaxos?</title><link>https://skoya76.github.io/posts/distsys/multipaxos/</link><pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/multipaxos/</guid><description>本記事はdev.toから移植しました．
Introduction In my last article, I wrote about Paxos (What is Paxos?). Paxos could only determine a single value. Nothing more, nothing less.
SMR and Total Order Broadcast SMR (State machine replication) is a method of achieving fault-tolerant service by replicating servers and having those servers cooperate. All replicated servers (replicas) have exact copies. This allows for improved availability by allowing a replacement replica to provide service in the event of a failure of one of the replicas.</description></item><item><title>What is the Paxos?</title><link>https://skoya76.github.io/posts/distsys/paxos/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/distsys/paxos/</guid><description>本記事はdev.toから移植しました．
Introduction Paxos is a consensus algorithm in distributed systems. The consensus algorithm is an algorithm that determines (agrees on) a single value within a network of multiple nodes.
Paxos wants to do In a phrase, Paxos wants to determine a single value that will not be overturned. Specifically, computers that are independent of each other (do not share memory) and exchange information only through the network participate in the consensus, and if a majority of them choose the same value, them all learn that value and it cannot be overturned.</description></item><item><title>নোট সমূহ</title><link>https://skoya76.github.io/notes/_index.bn/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://skoya76.github.io/notes/_index.bn/</guid><description/></item><item><title>Go পরিচিতি</title><link>https://skoya76.github.io/notes/go/basic/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/go/basic/introduction/</guid><description> Hello World A sample go program is show here.
package main import &amp;#34;fmt&amp;#34; func main() { message := greetMe(&amp;#34;world&amp;#34;) fmt.Println(message) } func greetMe(name string) string { return &amp;#34;Hello, &amp;#34; + name + &amp;#34;!&amp;#34; } Run the program as below:
$ go run hello.go Variables Normal Declaration:
var msg string msg = &amp;#34;Hello&amp;#34; Shortcut:
msg := &amp;#34;Hello&amp;#34; Constants const Phi = 1.618</description></item><item><title>Go বেসিক</title><link>https://skoya76.github.io/notes/go/basic/_index.bn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/go/basic/_index.bn/</guid><description/></item><item><title>অ্যাডভান্সড</title><link>https://skoya76.github.io/notes/go/advanced/_index.bn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/go/advanced/_index.bn/</guid><description/></item><item><title>বেসিক টাইপ সমূহ</title><link>https://skoya76.github.io/notes/go/basic/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/go/basic/types/</guid><description>Strings str := &amp;#34;Hello&amp;#34; Multiline string
str := `Multiline string` Numbers Typical types
num := 3 // int num := 3. // float64 num := 3 + 4i // complex128 num := byte(&amp;#39;a&amp;#39;) // byte (alias for uint8) Other Types
var u uint = 7 // uint (unsigned) var p float32 = 22.7 // 32-bit float Arrays // var numbers [5]int numbers := [...]int{0, 0, 0, 0, 0} Pointers func main () { b := *getPointer() fmt.</description></item><item><title>Flow Control</title><link>https://skoya76.github.io/notes/go/basic/flow-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/go/basic/flow-control/</guid><description>Condition if day == &amp;#34;sunday&amp;#34; || day == &amp;#34;saturday&amp;#34; { rest() } else if day == &amp;#34;monday&amp;#34; &amp;amp;&amp;amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(&amp;#34;Uh oh&amp;#34;) Switch switch day { case &amp;#34;sunday&amp;#34;: // cases don&amp;#39;t &amp;#34;fall through&amp;#34; by default! fallthrough case &amp;#34;saturday&amp;#34;: rest() default: work() } Loop for count := 0; count &amp;lt;= 10; count++ { fmt.Println(&amp;#34;My counter is at&amp;#34;, count) } entry := []string{&amp;#34;Jack&amp;#34;,&amp;#34;John&amp;#34;,&amp;#34;Jones&amp;#34;} for i, val := range entry { fmt.</description></item><item><title>ফাইল ম্যানিপুলেশন</title><link>https://skoya76.github.io/notes/go/advanced/files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/go/advanced/files/</guid><description> Condition if day == &amp;#34;sunday&amp;#34; || day == &amp;#34;saturday&amp;#34; { rest() } else if day == &amp;#34;monday&amp;#34; &amp;amp;&amp;amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(&amp;#34;Uh oh&amp;#34;)</description></item><item><title>ব্যাশ ভেরিয়েবল</title><link>https://skoya76.github.io/notes/bash/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/bash/basic/</guid><description> Variable NAME=&amp;#34;John&amp;#34; echo $NAME echo &amp;#34;$NAME&amp;#34; echo &amp;#34;${NAME} Condition if [[ -z &amp;#34;$string&amp;#34; ]]; then echo &amp;#34;String is empty&amp;#34; elif [[ -n &amp;#34;$string&amp;#34; ]]; then echo &amp;#34;String is not empty&amp;#34; fi</description></item><item><title>Go এর নোট সমূহ</title><link>https://skoya76.github.io/notes/go/_index.bn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/go/_index.bn/</guid><description>Go Notes</description></item><item><title>KAGのインターンに参加したお話</title><link>https://skoya76.github.io/posts/internship/kag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/internship/kag/</guid><description>．．．</description></item><item><title>ব্যাশের নোট সমূহ</title><link>https://skoya76.github.io/notes/bash/_index.bn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/notes/bash/_index.bn/</guid><description>Bash Notes</description></item><item><title>楽天のインターンに参加したお話</title><link>https://skoya76.github.io/posts/internship/rakuten/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/internship/rakuten/</guid><description>なぜ参加しようとおもったか 選考に関して スケジュールと内容 感想</description></item><item><title>海外インターン（東レ）に参加したお話</title><link>https://skoya76.github.io/posts/internship/toray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://skoya76.github.io/posts/internship/toray/</guid><description>．．．</description></item></channel></rss>